# Java-Masterclass-2025--130-Hours-of-Expert-Lessons

## Section 3: First Step In Java Programming
15. Your First Java Program: Displaying "Hello World" and Basic Error Handling
16. Introduction to Variables, Keywords, and the Integer (int) Data Type
17. Using Variables in Java Expressions: A Comprehensive Introduction
18. Exploring Java Primitive Type: Integers Ranges and Wrapper Classes
19. Understanding Byte, Short, And Long Data types and their width in Java
20. Understanding and Using Casting with Numeric Primitive Types in Java
21. Primitive Types Challenge: Applying Your Knowledge of Integer Variables
22. Working with Float and Double: Precision in Floating Point Numbers
23. Understanding Floating-Point Precision: A Practical Challenge in Java
24. Exploring Character (char) and Boolean Primitive Data Types in Java
25. Recap of Primitive Types and Introduction to the String Class in Java
26. Mastering Operators, Operands, and Expressions in Java Programming
27. Simplifying Java Code: Using Abbreviated Operators for Concise Operations

## Section 4: Transitioning from JShell to IDE: A Comprehensive IDE Guide.
33. Creating Your First IntelliJ Project: "Hello World" Java Code Implementation
34. Understanding IntelliJ Code Structure: Classes, Methods, and Basic Java Syntax
35. Mastering Java's if-then Statement: Conditional Logic for Program Flow Control
36. Advanced Conditional Logic: Implementing the Logical AND Operator in Java Code [Code Practice]
37. Java's Logical OR Operator: Enhancing Conditional Statements for Flexible
38. Assignment vs. Equality: Avoiding Common Java Operator Errors in IntelliJ
39. Streamlining Code: Implementing Java's Ternary Operator for Concise Conditionals
40. Java Operator Precedence: Mastering Expression Evaluation and Challenge

## Section 5: Mastering Java Expressions, Statements, Code Blocks, And Method Overloading

41. Introduction To The Fundamentals Of Java Workflow

42. Exploring Java Keywords And Understanding Expressions
43. Mastering Java Statements, Whitespace, And Code Organization
44. Harnessing Code Blocks And The If-Then-Else Statement In Java
45. Practical If-Then-Else Challenge For Java Flow Control
46. Deep Overview Of Methods In Java For Reusable Code
47. Enhancing Skills With Additional Java Method Techniques
48. Comprehensive Recap Of Java Methods
49. Hands-On Java Method Challenge For Deeper Practice
50. Comparing And Reviewing Code In IntelliJ For Better Development
51. Introduction To Java Coding Exercises For Skill Development [Exercise]
52. Delving Into Method Overloading In Java
53. Practical Method Overloading Challenge To Strengthen Java Expertise
54. Comprehensive Seconds-And-Minutes Challenge For Time-Based Calculations
55. Detailed Bonus Challenge Solution And Key Insights [Exercise]

## Section 6: Mastering Conditional Logic, Loops, And Interactive Java Applications

57. Exploring The Traditional And Enhanced Switch Statements
    1. Switch Statement
    2. Switch Value Types
    3. Fall Through in switch statement

58. Delving Deeper Into Advanced Switch Statement Features
    1. Traditional Switch Statement vs Enhanced Switch Statement
    2. Yield Keyword
    3. When to use yield in a switch

59. Traditional Switch Statement Challenge And Practical Exercises
    1. Switch Challenge (Traditional)

60. Embracing Switch Expressions With A Hands-On Coding Challenge
    1. Switch Challenge - Day of the Week Challenge (Enhanced)

61. Mastering The for Statement For Repetitive Task Automation
    1. Java supports three statement for looping
    2. The for statement
    3. Mini Challenge [Challenge]
    4. The break statement

62. Comprehensive for Loop Challenge To Strengthen Iteration Skills
    1. Prime Number Challenge
    2. The For Loop Challenge

63. Sum 3 And 5 Challenge With Vscode Debugger Insights
    1. Sum 3 and 5 Challenge
    2. Debugging Tool

64. for Loop Recap And Key Takeaways For Iteration In Java
    1. The for Statement Recap

65. The while And do-while Statements For Conditional Looping
    1. Other ways to Loop
    2. Java has two types of while loops
    3. The for statement and the while statement
    4. The while statement and do while statement
    5. continue

66. Practical while Loop Exercises And Challenges
    1. The while loop challenge - Step 1
    2. The while loop challenge - Step 2

67. Digit Sum Challenge And Further Looping Techniques
    1. Digit Sum Challenge
    2. Digit Sum Challenge Process, Step 1
    3. Digit Sum Challenge Process, Step 2 and 3
    4. Digit Sum Challenge Process, Final Step

68. Revisiting The while And do-while Loops: A Complete Recap
    1. The while Statement Recap
    2. The while and the do while
    3. Examine loop conditions carefully
    4. Continue and Break

69. Exploring Local Variables And Scope In Java Blocks
    1. Local Variables and Scope
    2. Local Variables
    3. Scope
    4. When are Local Variables in Scope?
    5. When are Local Variables out of Scope?
    6. Scope Best Practices
    7. Local Variables and the For Statement 
    8. Declaring variable in a switch statement block

70. Understanding Classes, Objects, And Static Versus Instance Members
    1.The class, the object, static & instance fields and methods
    2. A class
    3. The class is a template for creating objects
    4. An object
    5. A class and objects
    6. Declaring and instantiating a new object from a Class
    7. static and instance fields
    8. static and instance methods

71. Parsing Values And Reading Console Input – system.console() Overview
    1. Parsing Values and Reading Input using System.console()
    2. Summary of Operators
    3. Wrapper methods to parse strings to numeric values
    4. Reading data from the console
    5. Read Input Practice

72. Handling Exceptions And Introducing The Scanner Class
    1. What's an exception?
    2. Catching an exception
    3. The try statement
    4. The Scanner class
    5. new keyword
    6. Instantiating Scanner
    7. Using the import statement

73. Reading Input With The Scanner For Seamless User Interaction
    1. ReadingUserInput Improvement

74. Hands-On Reading User Input Challenge For Practical Mastery
    1. Challenge

75. Identifying Min And Max Values – A Final Control Flow Challenge
    1. Min and Max Challenge

## Section 7: Mastering Java OOP: Classes & Inheritance

76. Welcome to Java OOP Inheritance
    1. Fundamentals OOP
        - Classes
        - Objects
        - Constructors
    2. Features of OOP
        - Inheritance
        - Encapsulation
        - Polymorphism
        - Composition

77. Deep Dive into Classes and Objects
    1. What is OOP
    2. Class-based Programming
    3. Real World Object Exercise
    4. State and Behavior 
    5. State (computer) & Behavior (computer)
    6. State (ant) & Behavior (ant)
    7. State and Behavior (Definition)
    8. The class as the blueprint
    9. Organizing classes
    10. Access modifiers for the class
    11. Encapsulation

78. Getters, Encapsulation, and Object Access
    1. What is null?
    2. Default values for field on classes
    3. What are getters and setters? Why should we use them?

79. Setters, Object Creation, and OOP Practice
    1. this keyword

80. Classes Challenge: Building a Bank Account
    1. Class and OOP Challenge

81. Constructors Part 1: Object Initialization
    1. Constructor
    2. The default constructor
    3. Constructor Overloading

82. Constructors Part 2: Overloading and Chaining
    1. Constructor chaining with this()

83. Constructor Challenge: Building Customer Data
    1. Constructor Challenge Exercise

84. Understanding References, Objects, and Instances
    1. Object vs Instance vs Class
    2. Reference vs Object vs Instance vs Class
    3. The reference vs The object

85. Static vs. Instance Variables in Java
    1. Static Variables
    2. Instance Variables

86. Static vs. Instance Methods Explained
    1. Static Methods
    2. Instance Methods
    3. Static or Instance Method

87. POJOs: Plain Old Java Objects
    1. Plain Old Java Object
    2. The Entity - The Student Table
    3. Annoation
    4. Overriden Methods

88. Java Records: The Modern POJO Approach
    1. The Record type
    2. Implicit or Generated Code that Java provides
    3. Why have an immutable record?
    4. POJO vs. Record
    5. Java's new type, the record

89. Inheritance - Part 1: The Basics
    1. Inheritance
    2. The Animal class
    3. Class Model for Animal and Dog
    4. super()

90. Inheritance - Part 2: Extending Animal Class
    1. Code Re-use
    2. Overriding a method
    3. Overridden method

91. Inheritance - Part 3: Unique Dog & Fish Classes
    1. Class Diagram for Dog and Animal
    2. Class Diagram with additional class, Fish
    3. Polymorphism

92. Unveiling java.lang.Object in Java
    1. java.lang.Object
    2. Class Diagram for Student and PrimarySchoolStudent

93. Inheritance Challenge - Designing a Worker Hierarchy
    1. Inheritance Challenge [employee, worker]

94. Inheritance Challenge Part 2: Specialized Employees
    1. Inheritance Challenge, Continued
    2. SalariedEmployee
    3. HourlyEmployee class
    4. Making the call

95. Using this and super for Constructors
    1. this vs super
    2. Keyword this
    3. Keyword super
    4. this() vs super() calls
    5. Constructors Bad Example
    6. Constructors Good Example
    7. Comparing Both Examples

96. Method Overloading vs. Overriding Explained
    1. Method Overloading
    2. Method Overloading Rules
    3. Method Overriding
    4. Method Overriding Rules
    5. Method Overriding vs. Overloading
    6. Coveriant Return Type

97. Text Blocks & Advanced Output Formatting
    1. What's a Text Block?
    2. Some Common Escape Sequence
    3. Format Specifiers

98. Revisiting the String: Methods and Best Practices
    1. The String
    2. The Purpose of String methods
    3. String Inspection Methods
    4. String Comparison Methods

99. Mastering String Manipulation Methods
    1. String comparision Methods

100. The StringBuilder: Efficient Mutable Strings
    1. String vs StringBuilder
    2. Creating Instances
    3. String
    4. StringBuilder
    5. String methods vs. StringBuilder methods
    6. Some methods unique to the StringBuilder class
    
# Section 8: Advanced OOP Techniques: Composition, Encapsulation, and Polymorphism in Action

102. Building a Computer with Composition: Understanding Has-A vs. Is-A in Java
    1. Composition
    2. Inheritance
    3. Inheritance vs. Composition
    4. The parts
    5. PersonalComputer

103. Assembling a Personal Computer: Real-World Composition and Object Management
    1. Composition
    2. Composition is creating a whole from different parts.
    3. Use Compsition or Inheritance or Both?
    4. Why is Composition preferred over Inhertance in many designs?
    5. Why is Inheritance less flexible?
    6. Adding a Digital Product
    7. Revised Class Diagram

104. Hands-On Smart Kitchen Challenge: Modeling IoT Appliances with Composition
    1. The Composition Challenge

105. Encapsulation Essentials, Part 1: Data Hiding and Simplifying Interfaces
    1. What does Encapsulation Mean?
    2. Why hide things?
    3. What do we mean by interface here?
    4. The Player Class
    5. Problem one
    6. Problem Two
    7. Problem Three

106. Encapsulation Deep Dive, Part 2: Enhancing Classes and Securing Data
    1. The problem when classes aren't properly encalsulated
    2. Benefits of Encapsulation
    3. Staying in Control
    4. Encapsulation Principles

107. Encapsulation Challenge: Building a Printer with Toner and Duplex Functionality
    1. Encapsulation Challenge
    
108. Polymorphism Foundations, Part 1: Introducing Movie Subclasses for Runtime Varia
    1. Polymorphsim
    2. Movie Genres Code Practices

109. Polymorphism in Practice, Part 2: Factory Methods, Runtime Types, and Movie Scen
    1. Imports
    2. Polymorphism in action

110. Advanced Casting and var Usage: Navigating Compile-Time vs. Runtime Types in Java
    1. What is var?
    2. Local Variable Type Infererence (LVTI)
    3. Run Time vs. Compile Time Typing

111. Runtime Type Inspection: Mastering instanceof and Pattern Matching in Java
    1. Evaluating what the runtime type is
    2. instanceof operator
    3. Pattern Matching for the instanceof Operator

112. Polymorphism Challenge: Building Gas, Electric, and Hybrid Car Classes in Java
    1. Polymorphism Challenge

113. Polymorphism Challenge, Part 2: Finalizing Car Inheritance and Overridden Method
    1. The Challendge, the Car Class Diagram [continued]

114. OOP Master Challenge, Part 1: Crafting a Burger Restaurant App with OOP Concepts
    1. Welcome to the Object-Oriented Programming Master Challenge!
    2. Bill's Burger Challenge
    3. Initial Design Considerations

115. OOP Master Challenge, Part 2: Implementing Meal Orders and Pricing Strategies
    1. Continued + MealOrder Challenge

116. OOP Master Challenge: Deluxe Burger Bonus Adding Specialized Topping and Pricing.
    1. Bills Burger Challenge with the Bonus - the DeluxeBurger

117. Project Structure and Modular Design: Harnessing Packages and Import Statements
    1. Orgainizing Java Classes
    2. package
    3. Java packages
    4. Using classes from packages other than java.lang - the import statement
    5. Multiple import statement
    6. Using import statements with wildcards
    7. What is the purpose of packages?
    8. What would a package name look like?
    9. using the package statement
    10. The Fully Qualified Class Name (FQCN)
    11. The Fully Qualified Class Name vs the import statement
    12. Using the package statement

# Section 9: Advanced Arrays in Java: Single & Multi-Dimensional Techniques

118. Arrays Introduction: Handling Multiple Values Efficiently in Java
    1. Array Introduction

119. Declaring, Initializing, and Accessing Arrays: Foundational Principles
    1. Arrays
    2. Declaring an Array
    3. Instantiating an Array
    4. An Array is NOT Resizable.
    5. The array initializer
    6. The array initizalizer as an anonymous array

120. Populating, Looping, and Searching: Deeper into Java Arrays
    1. What is an array, really?
    2. Array initialization and default element values
    3. The Enhanced For Loop, the For Each Loop
    4. java.util.Arrays
    5. Printing elements in an array using Arrays.toString()

121. Sorting, Filling, and Copying: Mastering the java.util.Arrays Helper Class
    1. Why use arrays?

122. Binary Search & Equality Checks: Speedy Lookups and Comparisons in Arrays
    1. Finding a match
    2. Searching Sequentially
    3. Using intervals to Search
    4. Arrays.binarySearch

123. Descending Sort Challenge: Building Your Array Skills with Real Data
    1. The Array Challenge

124. Common Pitfalls & Best Practices: A Comprehensive Arrays Recap
    1. Arrays Recaps
    2. Array Recap - Creating a New Array
    3. First Common Error
    4. Second Common Error
    5. Third Common Error
    6. Use Enhanced For Loop to avoid some of these errors.

125. Reference vs. Value Types: Understanding Array Memory and Method Calls
    1. Reference Types vs. Value Types

126. Embracing varargs: Flexible Method Parameters and Array Conversions
    1. Arrays as method parameters
    2. Variable argument (varargs)
    3. When can we use variable arguments (varargs)?

127. Finding the Smallest Value: A Hands-On Minimum Element Challenge
    1. Minimum Element Challenge

128. Reversing Arrays In-Place: Hands-On Practice with Swapping Elements
    1. The Reverse Array Challenge

129. Navigating 2D Arrays: Matrix Representation and Nested Loop Traversals
    1. Java's nested Arrays
    2. Two-Dimentional Array
    3. Accessing elements in multiple-dimensional arrays

130. Expanding to Multi-dimensional Arrays: Jagged Structures and Complex Data
    1. Two dimensional Array
    2. Multi Dimensional Array

# Section 10: Mastering Lists, Iterators, and Autoboxing: ArrayList, LinkedList & Enums

131. Introduction to Java Collections: Beyond Basic Arrays
    1. Introduction

132. Meet the List Interface & ArrayList (Part 1)
    1. Java Array vs Java List
    2. So what is a List?
    3. The ArrayList

133. ArrayList Methods (Part 2): Add, Remove, and More
    1. Continue Code Practice

134. ArrayList Methods (Part 3): Sorting, Copying & Searching
    1. Continue Code Practice, MoreList

135. Arrays vs. ArrayLists: A Practical Comparison
    1. Arrays vs ArrayLists
    2. Instantiating without Values
    3. Instantiating with Values
    4. Element information
    5. Getting a String representation for Single Dimension Arrays and ArrayLists
    6. Finding an element in an Array or ArrayList
    7. Sorting
    8. Array as an ArrayList
    9. Creating Special Kinds of Lists

136. ArrayList Challenge Part 1: Building an Interactive Grocery List
    1. The ArrayList Challenge

137. LinkedList Overview: Memory, Big O, and Why LinkedList Exists
    1. Array of primitive values
    2. Arrays and ArrayLists of reference types
    3. ArrayList capacity
    4. ArrayList capacity is reached
    5. Big O Notation
    6. Constant Amortized Time Cost
    7. ArrayList Operations - Big O
    8. LinkedList
    9. LinkedList - Retrieval of an Element costs more than an ArrayList retrieval
    10. LinkedList - Inserting or Removing an Element may be less costly than using an ArrayList
    11. LinkedList and ArrayList Operations - Big O
    12. Things to Remember when consisdering whether to use an ArrayList vs LinkedList

138. LinkedList Essentials (Part 1): Adding & Removing Elements
    1. LinkedList
    2. A Queue is a First-In, First-Out (FIFO) Data Collection
    3. A Stack a is Last-In, First-Out (LIFO) Data Collection

139. LinkedList Essentials (Part 2): Retrieving & Itinerary Example
    1. 

140. Iterators Explained: Navigating Lists with Forward & Reverse
    1. What's an Iterator?
    2. How does an Iterator work?
    3. Iterator vs. ListIterator
    4. Iterator position vs. Element positions

141. LinkedList Challenge: Ordered Travel Itinerary (Part 1)
    1. LinkedList Challenge

142. LinkedList Challenge Continued: Interactive Navigation
    1. LinkedList Challenge Continued
    2. Reversing Directions in a List Iterator

143. Introduction to Autoboxing & Unboxing: Moving Between Primitives & Wrappers
    1. Why does Java have primitve data types?
    2. What is Boxing?
    3. How do we box?
    4. Deprecated Boxing using the wrapper constructor
    5. Deprecated Code
    6. Using new (with a constructor) is depcrecated for wrappers
    7. What is autoboxing?
    8. Automatic unboxing

144. Autoboxing & Unboxing for Arrays & Lists: Working with Wrapper Classes

145. Autoboxing & Unboxing Challenge: Simple Banking App (Part 1)
    1. Autoboxing Challenge with ArrayLists

146. Autoboxing & Unboxing Challenge: Bank & Customer Implementation (Part 2)

147. Enums Demystified: Declaring & Using Predefined Constants

148. Enums (Part 2): Switch Expressions & Custom Methods in Enums

# Section 11: Mastering Abstraction & Interfaces: Expand Polymorphism & Java Hierarchies

149. Abstraction & Generalization: Less Code, More Extensibility
    1. 

150. Exploring Abstract & Interface Modifiers: Real-World Modeling in Java
    1. Generalization and Abstraction
    2. Abstraction
    3. Java's support for Abstraction
    4. Abstract method
    5. Concrete method
    6. Method Modifiers

151. Diving into Abstract Classes (Part 1): Creating Flexible Hierarchies
    1. Abstraction - What is it?
    2. The abstract class
    3. What's an abstract method?
    4. What good is an abstract method, if it doesn't have any code in it?
    5. Animal and Dog Class Diagram from our Inheritance example

152. Diving into Abstract Classes (Part 2): Polymorphic Behavior & Implementation
    1. Code Challenge

153. Diving into Abstract Classes (Part 3): Advanced Hierarchies & Use Cases
    1. Continued code practice
    2. An Abstract class doesn't have to implement abstract methods
    3. Why use an abstract class?

154. Abstract Class Challenge (Part 1): Building a Storefront & Product Hierarchy
    1. Abstract Class Challenge

155. Abstract Class Challenge (Part 2): Finalizing the Store & Order System
    1. Abstract Class Challenge Continued

156. Interfaces (Part 1): Harnessing Contracts & Polymorphic Behavior in Java
    1. Interface vs. Abstract class
    2. Declaring an interface
    3. Using an interface
    4. A class can use extends and implements in same declaration
    5. The abstract modifier is implied on an interface
    6. All members on an interface are implicitly public

157. Interfaces (Part 2): Multiple Implementations & Real-World Examples
    1. The Bird Class
    2. The FlightEnabled Interface
    3. The final modifier in Java
    4. Constatns in Java
    5. A field declared on an Interface is always public, static and final 

158. Interfaces (Part 3): Constants, Conversion & Flexible Abstractions
    1. Extending Interfaces
    2. Implements is invalid on an interface
    3. Abstracted Types - Coding to an Interface
    4. Coding to an interface

159. Interfaces & JDK 8 Enhancements: Default/Static Methods for Compatibility
    1. What's happended to the Interface since JDK 8
    2. The Interface Extension Method - the default method (as of JDK8)
    3. Overriding a default method

160. Interfaces & JDK 9 Enhancements: Private & Static Methods in Action
    1. public static methods on an interface (as of JDK 8)
    2. Private methods (JDK 9)

161. Interface vs. Abstract Class: Key Differences & Best Use Cases
    1. Abstract Class
    2. Use an Abstract class when...
    3. Interface
    4. Use an interface when...
    5. Interfaces are the used in many of Java's own features
    6. Interface vs. Abstract Class

162. Interface Challenge (Part 1): Creating Mappable Classes & GeoJSON-Like Output
    1. The interface Challenge
    2. The Class Diagram

163. Interface Challenge (Part 2): Finalizing Mapping Logic & Extended Features=

## Section 12: Deep Dive into Java Generics: Bounds, Comparators & Advanced Techniques

164. Generics Overview: Why Type Parameters & Where They Excel
    1. Generic Introduction

165. Creating Your First Generic Class: From Basics to Implementation
    1. What are Generics?
    2. Declaring a Class vs. Declaring a generic Class
    3. Using a generic class as a reference type

166. Refining Generic Classes: Polymorphism & Type Safety
    1. Solution 1: Duplicate code
    2. Solution 2: Use a Player interface or abstract class to support different types of players
    3. Generic Type Parameters
    4. Raw usage of generic classes.

167. Advanced Generics: Multiple Type Parameters & Bounded Types
    1. Generic classes can be bounded, limiting the types that can use it.
    2. Why specify an upper bound?

168. Generic Class Challenge (Part 1): Building Reusable Structures
    1. Generic Class Challenge

169. Generic Class Challenge (Part 2): Finalizing Maps & Overviews
    1. continued Generic Class Challenge

170. Comparable Revisited: Sorting Objects by Natural Order
    1. Interfaces used for sorting
    2. Comparable Interface

171. Comparable vs. Comparator: Distinctions & Sorting Strategies
    1. The Comparator Interface
    2. Summary of Differences

172. Generic Classes as Reference Types: Wildcards & Method Parameters
    1. What's left to know about Generics?
    2. This isn't inhertice

173. Generic Methods, Wildcards & Type Erasure: Handling Advanced Cases
    1. Limitation of a reference of generic class with a list argument
    2. The generic method
    3. Type Paramters, Type Arguments and using a WildCard
    4. Type Erasure

174. Static Methods in Generics & Multiple Upper Bounds Explained
    1. Using Multiple types to declare an Upper Bound 

175. Final Generics Challenge: Integrating Bounded Types & Comparators
    1. Putting it all together, Final Section Challenge

# Section 13: Exploring Nested Classes, Local Types & Anonymous Classes

176. Understanding Nested Classes: Overview & Types
    1. Nesting classes (or types) within another class (or type)
    2. Nested Classes
    3. Important Restrictions for nested classes were removed in JDK16

177. Static Nested Classes: Encapsulation & Access Rules
    1. Static Nested Class

178. Inner Classes: Non-Static Nesting & Syntax
    1. Inner Classes

179. Applying Inner Classes: Bill’s Burger Revisited
    1. Continued Code Practice

180. Inner Classes Challenge: Practical Enhancements
    1. Bills Burgers with Inner Classes

181. Local Classes: Scoping & Effective-Final Variables
    1. Local Classes
    2. Local Class's 'Captured Variables'
    3. Final Variables and Effectively Final
    4. Effectively Final
    5. Additonal Local Types

182. Anonymous Classes: Inline Instantiation & Use Cases
    1. Anonymous Classes
    2. Anonymous class creation

183. Local & Anonymous Classes Challenge
    1. The Local and Anonymous Class Challenge

# 184. Introduction to Lambda Expressions: Revolutionizing Java Code with Conciseness

184. Introduction to Lambda Expressions: Revolutionizing Java Code with Conciseness
    1. Introduction to Lambda Expressions

185. Deep Dive into Lambda Expressions and Functional Interfaces: Practical Examples
    1. The Lambda Expression
    2. The Syntax of a Lambda Expression
    3. Comparing the anonymous class and the lambda expression
    4. Where's the method in the lambda expression?
    5. How can Java infer the method?
    6. What's a functional interface?

186. Exploring Lambda Expression Syntax: Variations, Rules, and Advanced Examples
    1. The Lambda Expression
    2. The Consumer Interface
    3. Streams

187. Custom Functional Interfaces: Building Reusable Lambda Expressions in Java
    1. Lambda expessions with multiple paramters
    2. Lambda expressions that return values

188. Exploring Java's Built-In Functional Interfaces: Consumer and Predicate
    0. Java's Functional Interfaces, Consumer & Predicate
    1. java.util.function
    2. The Four categories of Functional Interfaces
    3. The Consumer interface
    4. A Consumer Lambda Expression Example
    5. The Predicate Interface
    6. A Predicate Lambda Expression Example

189. Exploring Java's Built-In Functional Interfaces: Function and Supplier
    1. The Function interface
    2. A Function Interface Lambda Expression Example
    3. The Supplier Interface
    4. A Supplier Lambda Expression Example
    5. Valid Lambda Declarations for different number of arguments

190. Hands-On Practice: Lambda Mini-Challenges for Skill Reinforcement and Mastery
    1. Lambda Mini Challenges
    2. Mini Challenge 1, 2, 3, 4, 5, 6, 7

191. Lambda Expression Challenge: Applying Skills with Arrays, Lists, and Operations
    1. Lambda Expression Challenge

192. Demystifying Method References: Simplifying Lambda Expressions in Java Code
    1. What's a Method Reference?
    2. Why are these statements equal?
    3. What methods can be used in method references?
    4. Deferred Method Invocation

193. Understanding the Most Complex Method References: Unbounded Receiver Explained
    1. Some Terminology for the next couple of Slides
    2. Four Types of Method References
    3. Method Reference Example (No arguments and one argument)
    4. Method Reference Examples (Two Arguments)

194. Hands-On Practice: Method Reference Challenge for Practical Skill Development
    1. Method and Lambda Challenge

195. Chaining Lambdas: Leveraging Convenience Methods on Functional Interfaces
    1. Convenience Methods

196. Advanced Comparator Usage: Leveraging Convenience Methods for Enhanced Sorting
    0. Convenience Methods, Continued, with the Comparator
    1. Convenience Methods on functional interfaces in java.util.function package
    2. Comparator's additional helper methods

# Section 15: Mastering Java Collections: Framework, Lists, Sets, and Maps

197. Java Collections Framework: An In-Depth Introduction for Beginners
     1. Introduction Collection Framework

198. Deep Dive into Java Collections: Core Interfaces and Big Picture
     0. Collections: Understanding the Big Picture
     1. A Collection Framework
     2. What's in the framework, what's not?
     3. The Collection Interface
     4. Collections - The Big Picture
     5. The List
     6. The Queue
     7. The set
     8. The Map
     9. What's a polymorphic algorithm?

199. Creating a Versatile Deck of Cards in Java: Code Setup & Best Practices
     1. The Code Setup
     2. The class diagram for my solution

200. Exploring java.util.Collections: Essential Methods and List Operations
     0. Introduction to jaa.util.Collections
     1. What's a Collections Class?
     2. The Setup - a Quick Review

201. Advanced java.util.Collections: Shuffle, Reverse, Sort, indexOfSubList
     0. java.util.Collections (shuffle, reverse, sort, indexOfSubList)

202. Mastering java.util.Collections: binarySearch, frequency, min, max, rotate
     0. java.util.Collections (binarySearch, frequency, min, max, rotate)

203. Challenge: Building a Custom Card Game with java.util.Collections
     0. Collections methods Challenge, Your own card
     1. The Card Game Challenge
     2. Poker: Five Card Draw

204. Completing the Collections Challenge: Five Card Draw (Poker)
     0. Collection Methods Challenge, (Five Card Draw), continued

205. Java Hash Codes Explained: Mastering the Basics for Effective Collections
     0. Understanding the importance of the hash code
     1. Hashing starts with understanding equality
     2. The equals method on Object
     3. Do we remember what == means for objects?
     4. Equality of Objects
     5. The visual representaiton of the code
     6. Creating the hashCode method
     7. Java's Hashed Collection Types

206. Preparing for Sets and Maps: Setting Up Phone and Email Contacts in Java
     1. The setup
     2. The Setup Challenge - The Contact Class
     3. The Setup Challenge - The Data (ContactData class)

207. Introduction to Java Sets and HashSet: Mastering Unordered Collections
     0. Introduction to Sets & HashSet
     1. The Set
     2. Set methods
     3. The HashSet class

208. Java Set Operations Explained: Mastering Union, Intersection, & Difference
     0. Set Operations, Symmetric and Asymmetric results
     1. Set Operations
     2. Representating Sets in a Venn Diagram
     3. Set Operations - Union A ∪ B
     4. Set Operations - Interact - A ∩ B
     5. Set Operations - Symmetric Operations
     6. Set Operations - Asymmetric Differences
     7. Set Operations - Symmetric Differnces
209. Java Set Operations Challenge: Setting Up Task and TaskData Classes
     0. Code Setup (Tasks and TaskData)
     1. Set Operations Challenge - Task Class
210. Java Set Operations Challenge: Real-World Application with Task Management
     0. Set Operations Challenge
211. Exploring LinkedHashSet and TreeSet: Ordered Sets in Java
     0. LinkedHeshSet and TreeSet
     1. Ordered Sets
     2. The LinkedHashSet
     3. TreeSet
     4. TreeSet O Notation
     5. The TreeSet interface hierarchy
     6. The TreeSet relies on Comparable or Comparator methods

212. Java TreeSet Mastery: Navigating with Closest Match and Subset Methods
     0. TreeSet, Closet match and subset methods
     1. NavigableSet methods to get closet matches
     2. Getting subsets from a TreeSet.
     3. WHen would we use a TreeSet?

213. Challenge: Building a Robust Theatre Seat Booking System with TreeSet
     0. TreeSet Challenge (Theatre Seats)
     1. The TreeSet Challenge (Theatre Seating)
     2. The Theatre Challenge Bonus

214. Completing the Theatre Seat Booking System Challenge
     0. Continue TreeSet Challenge (Theatre Seat Bonus)
215. Comprehensive Guide to the Java Map Interface and Its Functionality
     0. The Map Interface and functionality
     1. The Map Interface, why is it different?
     2. Map characteristics
     3. Map Implementations (the classes that implement Map)

216. Advanced Map Operations: compute, replace, and remove Methods Explained
     0. Map functionality continued (compute, computeIfPresent, computerIfAbsent)

217. Mastering Map View Collections: keySet, values, and entrySet in Java
     0. Working with Map's view collections (KeySet, Values, entrySet)
     1. What's a view?
     2. The purpose of view collections
     3. The HashMap's implementation
     4. The Map's view collections
     5. Functionality available to set returned from keySet()

218. Challenge: Build a Text-Based Adventure Game with Java HashMap
     0. HashMap Challenge, A Text-Based Adventure Game
     1. The Adventure Game
     2. The Adventure Game's Conceptual Map
     3. The Adventure Game

219. Completing the Text Adventure Game Challenge
     0. HashMap Challenge, A Text-Based Adventure Game

220. Exploring LinkedHashMap and TreeMap: Ordered Maps in Java
     0. LinkedHashMap and TreeMap
     1. Orderd and Sorted Map implementations

221. Mastering TreeMap: NavigableMap Methods for Efficient Data Handling
     0. Working with TreeMap(NavigableMap) methods
     1. TreeMap's View collections

222. EnumSet and EnumMap: Optimizing Collections for Enum Types in Java
     0. Targeted Collections for enum types
     1. EnumSet and EnumMap
     2. The EnumSet
     3. The EnumMap
     4. Two Types of EnumSet implementations
     5. Ann's Work Day EnumSet

223. Collection Framework Final Challenge Part 1
     0. Collections Framework Final Challenge(The Setup)
     1. Build a Store's Inventory System
     2. Product and InventoryItem
     3. The Cart
     4. The Store
     5. Try to use a variety of Collections Framework implementations and methods

224. Building a Complete Store Inventory Management System (Part 1)
     0. Final Challenge(Store Inventory)

225. Building a Complete Store Inventory Management System (Part 2)
     0. Final Challenge (Store Inventory)

# Section 16: Mastering Mutability, Immutability and Final Keyword in Java OOP

226. Mutable vs Immutable Objects in Java: Advantages, Disadvantages, and Design
     0. Using Final, Immutable & Sealed classes, Constructors & Initializers: Introduction
     1. Mutable vs Immuable
     2. Immuable Objects - Advantages
     3. Immuable Objects - Disadvantages
     4. Classes must be designed to produce Immutable Objects

227. Deep Dive into the Final Modifier: Methods, Fields, Classes, Variables
     0. Revisiting the final modifier
     1. The final modifier in Java
     2. Using the final modifier on methods

228. Final Modifier: Static Methods, Hiding vs. Overriding, Final Variables
     0. The final modifier applied to methods, and local variables
     1. Hiding vs. Overriding
     2. Recommendation: Always use the type, to invoke the static method
     3. Using final for variables

229. Understanding Side Effects of Mutability: Defensive Coding Techniques
     0. When Change isn't good
     1. Formatting Date Time
     2. Format Date and Time
     3. Controlling Change

230. Designing Immutable Classes: Private Final Fields, Defensive Copies - Part 1
     0. Declaring immutable classes to produce immutable object, Part 1
     1. Immutable Object
     2. Strategies for Declaring a Class, to produce immutable objects

231. Creating Truly Immutable Java Classes: Preventing Subclass Modification
     0. Declaring immutable classes to produce immutable object, Part 2

232. Implement Immutable BankAccount and BankCustomer Classes in Java
     0. Challenge: Write our own immutable classes
     1. Challenge: Write Immutable classes for a Bank Account and a Bank Customer

233. Shallow vs. Deep Copies: Protecting Data Integrity in Java Applications
     0. Defensive Copies, Shallow and Deep Copies
     1. Defensive Copies as Input
     2. Defensive Copies as output
     3. What's a copy? Shadow Copy vs Deep Copy
     4. Shallow Copy
     5. Deep Copy
     6. Shallow Copy vs Deep Copy of a composite object

234. Immutable Collections, Unmodifiable Views: Limitations and Best Practices
     0. Immutable, Unmodifiable Collections and Views
     1. Unmodifiable Collections are NOT immutable collections
     2. Unmodifiable Collections vs. Unmodifiable Collection Views

235. Implementing Unmodifiable Collections in a Banking Application
     0. Challenge: Use unmodifiable collections
     1. The Banking Account Application From the Immutable Class Challenge
     2. Modify the Banking Account Application from the Immutable Class Challenge
     3. Modify the BankAccount class
     4. Modify the BankCustomer class
     5. Implement a Bank
     6. Create and use a Bank in the Main's main method
     7. The Class Diagram (as I'll be coding it)

236. Building a Secure Banking Application: Implementing Transaction Handling
     0. Challenge, Continued: Using unmodifiable collections.
     1. The Class Diagram (as I'll be coding it)

237. Java Constructors: No-args, Initializers, Final Fields, and Inheritance
     0. Constructor review, final field initializations, Introduction to Initializers
     1. Why are we going to talk about constructors again?
     2. The instance initializer block
     3. Static Initializers

238. Demystifying Record Constructors: Canonical, Custom, and Compact Forms
     0. Record Constructors (and javap)
     1. Record Constructors come in three flavors
     2. The compact constructor
     3. The Java Class File Disassembler

239. Mastering Enum Constructors and Static Initializers in Java
     0. Enum Constructors

240. Building a Game Console Framework with Player Input
     0. Game Console Setup, Part 1
     1. Creating A Game Console
     2. GameConsole
     3. The GameAction record
     4. The Player Interface
     5. The Game Class
     6. The Conceptual Game Console Application

241. Building a Generic Game Console: Implementing Game and Player Interactions
     0. Game Consoler Setup, Part 2

242. Java Coding Challenge: Design a Pirate Adventure with Constructors & Initializer
     0. Challenge: Initializers and Constructors, A Pirate Game
     1. The Initializer Challenge, Pirate Invasion Game
     2. Class Diagram

242. Java Coding Challenge: Design a Pirate Adventure with Constructors & Initializer
     0. Challenge: A Pirate Game continued

244. Enhancing Code Security: Final Classes & Constructor Access Modifiers
     0. Final Classes, Review of constructor access modifiers
     1. Final Classes

245. Restricting Class Extension in Java with the Sealed Classes and Interfaces
     0. Sealed Classes
     1. Sealed Classes
     2. sealed class

246. Building a Complete Pirate Game: Loot, Combat, and Town Features in Java
     0. Final Section Challenge
     1. The Final Section Challenge
     2. Create a Sealed Combatant class
     3. Create Loot and Feature enums
     4. Create a Town Record

247. Final Java Game Enhancements: Implementing Town Features and Combat Interactions
     0. Final Challenge (Pirates Continued, Part 2)

## Section 6 - Code Exercise
    Chapter 60 = 2
    Chapter 64 = 1
    Chapter 70 = 12
    Chapter 75 = 2

## Re-check
    Section12: 

